# データ型

- Rust における値はすべて何らかのデータ型になる
- 2種のデータ型のサブセット
  - スカラー型
  - 複合型
- Rust は静的型付き言語
- 複数の型があり得る場合には型注釈を付けなければならない

```rs
let guess: u32 = "42".parse().expect("Not a number!");
```

## スカラー型

スカラー型は単独の値を表す。

- 整数
- 浮動小数点数
- 論理値
- 文字

### 整数型

- 整数型とは、`u32` 型など小数部分のない数値の型

表3-1: Rustの整数型

|大きさ| 符号付き| 符号なし|
|---|---|---|
|8-bit |i8 |u8|
|16-bit |i16 |u16|
|32-bit |i32 |u32|
|64-bit |i64 |u64|
|arch |isize |usize|

- `isize` と `usize` 型の大きさはプログラムが動作しているコンピュータの種類に依存する
  - 64 bit アーキテクチャなら 64 bit、32 bit アーキテクチャなら 32 bit
- 整数リテラル（リテラルとは、見たままの値ということ）は、表3-2に示すどの形式でも記述することができる
- バイトリテラルを除く数値リテラルは全て、型接尾辞（例: `57u8`）と `_` を見た目の区切り記号（例: `1_000`）に付加することができる

表3-2: Rustの整数リテラル

|数値リテラル| 例|
|---|---|---|
|10進数| 98_222|
|16進数| 0xff|
|8進数| 0o77|
|2進数| 0b1111_0000|
|バイト (u8だけ) |b'A'|

- Rust の基準型
  - 整数型の基準: `i32`

### 浮動小数点型

- `f32`
- `f64` （基準型）

```rs
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

### 数値演算

```rs
fn main() {
    // 足し算
    let sum = 5 + 10;

    // 引き算
    let difference = 95.5 - 4.3;

    // 掛け算
    let product = 4 * 30;

    // 割り算
    let quotient = 56.7 / 32.2;

    // 余り
    let remainder = 43 % 5;
}
```

### 論理値型

```rs
fn main() {
    let t = true;

    let f: bool = false; // 明示的型注釈付きで
}
```

### 文字型

- `char` はシングルクォーテーションを使用する
- 文字列型はダブルクォーテーションを使用する

```rs
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';    //ハート目の猫
}
```

- Rust の `char` 型はユニコードのスカラー値を表す

## 複合型

複合型により、複数の値を一つの型にまとめることができる。

- タプル
- 配列

### タプル型

```rs
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

タプルから個々の値を取り出すには、パターンマッチングを使用する。

```rs
let tup = (500, 6.4, 1);
let (x, y, z) = tup;
```

パターンマッチングを通しての分配の他にも、アクセスしたい値の番号をピリオド(.)に続けて書くことで、 タプルの要素に直接アクセスすることもできる。

```rs
let x: (i32, f64, u8) = (500, 6.4, 1);
let five_hundred = x.0;
let six_point_four = x.1;
let one = x.2;
```

### 配列型

- タプルとは違い、配列の全要素は同じ型でなければならない
- Rust の配列は固定長

```rs
let a = [1, 2, 3];
```

- 配列は、ヒープよりもスタックにデータのメモリを確保したいとき、あるいは常に固定長の要素があることを確認したい場合に有効
- 配列はベクタ型ほど柔軟ではない
- ベクタ型は可変長

#### 配列の要素にアクセスする

```rs
let a = [1, 2, 3, 4, 5];
let first = a[0];
let second = a[1];
```

#### 配列要素への無効なアクセス

配列の終端を超えて要素にアクセスしようとすると、コンパイルは通るが実行するとエラーで終了する。

```rs
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);   // 要素の値は{}です
}
```

```console
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
スレッド'<main>'は'範囲外アクセス: 長さは5ですが、添え字は10でした', src/main.rs:6
でパニックしました
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

これは、実際に稼働しているRustの安全機構の最初の例になる。低レベル言語のこの主のチェックは行われないため、間違った添え字を与えると無効なメモリにアクセスできてしまう。Rust では、メモリアクセスを許可し、処理を継続する代わりに即座にプログラムを終了することで、この種のエラーからプログラマを守っている。
